アイテムトレード仕様考案

1.api用ストレージを初期化
2.半径nメートル以内にUserName取得関数を実行させる
3.関数を実行したプレイヤーはエンダーチェストの0スロットに自分のプレイヤーヘッドをlootコマンドでreplace (取得パスは"EnderItems.[{Slot:0b}].tag.SkullOwner.Name")
4.プレイヤーヘッドに対象プレイヤーのUUIDをタグとして持たせる(トレード開始用のIDとなる)
5.それを0,-64,0のシュルカーボックスにappendしていく
6.シュルカーからデータをプレイヤーが受け取る

シュルカーボックスにアイテムを挿入する方法が思いつかないよ～；；
↓
アイテムはSlot番号を保有してるせいでappendした際に指定されたSlot番号に挿入されてしまう。
つまり、アイテムデータを取得した際にSlot番号のデータを削除することで解決できるかも？
lootでアイテム生成 -> アイテムデータを一度ストレージへ移す -> Slotを削除 -> シュルカーボックスへ移動

これ試してみる

↓

これloot insertすればSlot番号関係なかった。insert最高

---------

・どの人を選択したかの判別方法

個人ストレージを一時使用してシュルカーボックスの中身を個人ストレージに移動する
↓
ページが移動された際にインベントリの中身を一時保存ストレージに保存
↓
一時保存ストレージの中身から{UiItem:1b}を削除してプレイヤーヘッドのみにする
↓
[-1]から比較、一致したら削除を繰り返して、一致しなかった場合個人ストレージの中身からUUIDを取得して対象決定

実装完了!!
---------

UUIDでプレイヤー検知 -> PlayerID(スコア)でプレイヤー検知に変更

プレイヤーには全員個人ストレージ用のユニークスコアが割り振られている。
PlayerIDスコアを使ってプレイヤーの判定を行う。
現行のUUIDで判別は、ターゲットセレクタにNBTを使用していて処理が重たいため。

プレイヤーヘッドの生成時に使用するloot_tablesにscoreをnbt化して格納する処理を追加
↓
UUIDではなくPlayerIDの数値を用いて再帰で確認、#UI.Com Tempに数値格納 (これTempって勝手にこっちで使っていいのか？)
↓
execute if score @a PlayerID = #UI.Com Temp で実行者特定

----------