アイテムトレード仕様考案

1.api用ストレージを初期化
2.半径nメートル以内にUserName取得関数を実行させる
3.関数を実行したプレイヤーはエンダーチェストの0スロットに自分のプレイヤーヘッドをlootコマンドでreplace (取得パスは"EnderItems.[{Slot:0b}].tag.SkullOwner.Name")
4.プレイヤーヘッドに対象プレイヤーのUUIDをタグとして持たせる(トレード開始用のIDとなる)
5.それを0,-64,0のシュルカーボックスにappendしていく
6.シュルカーからデータをプレイヤーが受け取る

シュルカーボックスにアイテムを挿入する方法が思いつかないよ～；；
↓
アイテムはSlot番号を保有してるせいでappendした際に指定されたSlot番号に挿入されてしまう。
つまり、アイテムデータを取得した際にSlot番号のデータを削除することで解決できるかも？
lootでアイテム生成 -> アイテムデータを一度ストレージへ移す -> Slotを削除 -> シュルカーボックスへ移動

これ試してみる

↓

これloot insertすればSlot番号関係なかった。insert最高

---------

・どの人を選択したかの判別方法

個人ストレージを一時使用してシュルカーボックスの中身を個人ストレージに移動する
↓
ページが移動された際にインベントリの中身を一時保存ストレージに保存
↓
一時保存ストレージの中身から{UiItem:1b}を削除してプレイヤーヘッドのみにする
↓
[-1]から比較、一致したら削除を繰り返して、一致しなかった場合個人ストレージの中身からUUIDを取得して対象決定

実装完了!!
---------

UUIDでプレイヤー検知 -> PlayerID(スコア)でプレイヤー検知に変更

プレイヤーには全員個人ストレージ用のユニークスコアが割り振られている。
PlayerIDスコアを使ってプレイヤーの判定を行う。
現行のUUIDで判別は、ターゲットセレクタにNBTを使用していて処理が重たいため。

プレイヤーヘッドの生成時に使用するloot_tablesにscoreをnbt化して格納する処理を追加
↓
UUIDではなくPlayerIDの数値を用いて再帰で確認、#UI.Com Tempに数値格納 (これTempって勝手にこっちで使っていいのか？)
↓
execute if score @a PlayerID = #UI.Com Temp で実行者特定

----------

トレードするプレイヤー同士をどうやって判定する？
1. プレイヤー同士に一意のトレードIDを持たせて、同じトレードIDのプレイヤー同士をトレードさせる
　もし数値が衝突したら？ -> execute as @a if score @s InventoryUI.TradeID matchese XXX run scoreboard players add #dummy Temp 1 で人数確認してみる？

2. お互いの個人ストレージにお互いのPlayerIDを持たせて通信させる方法。 -> これお互いのインベントリを更新するときにちょっとめんどい可能性ある

[1,2,3,4,5]
[1,2,4,5]

execute store success で数値の比較
data modify でストレージの中身が書き換えられなかった = 戻り値が0 -> 一致
マクロ抜きでつくりなおす。

----------

tradeIDをどうにかしてtellrawに仕込みたい！？(無理)
どうにか送信相手にTradeIDを受け渡す方法を考える。

受信者の個人ストレージに送信者のTradeIDを一旦保存してみる？
Recastタイムを設定して、一度リクエストを受け取ったら一定時間受け取れないようにする -> 送信者も同じく

----------

準備完了の右側のスロットがお金。相手のお金は準備完了の左側。

----------

お互い準備完了になったら、準備完了プログラムを先に実行した人のみに、"TradeRunPlayer"タグを付与
"TradeRunPlayer"のインベントリをシュルカーに格納
お互いのインベントリの中身を削除
シュルカーからお互いにアイテムを分配
タグ削除。シュルカーのアイテム削除。
